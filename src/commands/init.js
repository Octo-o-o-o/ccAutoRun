/**
 * ccAutoRun init command
 *
 * Initialize ccAutoRun in a project directory
 */

import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import inquirer from 'inquirer';
import { Config } from '../utils/config.js';
import { getLogger } from '../utils/logger.js';
import { Errors } from '../utils/error-handler.js';
import YAML from 'yaml';

const logger = getLogger();

/**
 * Default Claude Code hooks configuration
 */
const HOOKS_CONFIG = `# Claude Code Hooks Configuration
# Generated by ccAutoRun

# User prompt submit hook - triggers auto-continue after each response
user-prompt-submit:
  command: node
  args:
    - .ccautorun/hooks/auto-continue.js
  enabled: true
  background: false
  timeout: 30000
`;

/**
 * Auto-continue hook script
 */
const AUTO_CONTINUE_SCRIPT = `#!/usr/bin/env node
/**
 * ccAutoRun Auto-Continue Hook
 *
 * This hook is triggered after each Claude response.
 * It checks if the current stage is complete and automatically
 * continues to the next stage.
 */

import { PlanParser } from '../../src/core/plan-parser.js';
import { SessionManager } from '../../src/core/session-manager.js';
import { SafetyLimiter } from '../../src/core/safety-limiter.js';
import { getLogger } from '../../src/utils/logger.js';

const logger = getLogger();

async function main() {
  try {
    // Hook implementation will be completed in Stage 3
    logger.debug('Auto-continue hook triggered');

    // TODO: Implement in Stage 3
    // 1. Parse current plan
    // 2. Check if stage is complete
    // 3. Load next stage if available
    // 4. Respect safety_limit

    process.exit(0);
  } catch (error) {
    logger.error('Hook error:', error);
    process.exit(1);
  }
}

main();
`;

export async function init(options = {}) {
  const {
    dryRun = false,
    setupHooks = false,
    enableHooks = false,
    force = false,
  } = options;

  logger.info('Initializing ccAutoRun project...');

  // Check if already initialized
  const config = new Config();
  const isInitialized = await config.isInitialized();

  if (isInitialized && !force) {
    if (dryRun) {
      logger.info(chalk.yellow('[DRY RUN] Project already initialized'));
      return;
    }
    throw Errors.alreadyInitialized();
  }

  // Prepare directory structure
  const dirs = [
    '.ccautorun',
    '.ccautorun/plans',
    '.ccautorun/sessions',
    '.ccautorun/logs',
    '.ccautorun/snapshots',
    '.ccautorun/archive',
    '.ccautorun/hooks',
  ];

  // Dry run mode - just show what would be created
  if (dryRun) {
    logger.info(chalk.cyan('\n[DRY RUN] Would create:'));
    for (const dir of dirs) {
      logger.info(`  ${chalk.gray('CREATE')} ${dir}/`);
    }
    logger.info(`  ${chalk.gray('CREATE')} .ccautorun/config.yaml`);

    if (setupHooks || enableHooks) {
      logger.info(`  ${chalk.gray('CREATE')} .claude/hooks.yaml`);
      logger.info(`  ${chalk.gray('CREATE')} .ccautorun/hooks/auto-continue.js`);
    }

    logger.info(chalk.green('\nâœ“ Dry run complete'));
    return;
  }

  try {
    // Create directory structure
    for (const dir of dirs) {
      await fs.mkdir(dir, { recursive: true });
      logger.debug(`Created directory: ${dir}`);
    }

    // Create default config.yaml
    await Config.createDefault();
    logger.success('Created default configuration');

    // Create .gitkeep files
    await fs.writeFile('.ccautorun/.gitkeep', '', 'utf-8');

    // Setup hooks if requested
    let hooksConfigured = false;
    if (setupHooks || enableHooks) {
      hooksConfigured = await setupClaudeHooks({ enableHooks, force });
    } else {
      // Ask user if they want to setup hooks
      const { shouldSetup } = await inquirer.prompt([
        {
          type: 'confirm',
          name: 'shouldSetup',
          message: 'Do you want to setup Claude Code hooks for auto-continue?',
          default: true,
        },
      ]);

      if (shouldSetup) {
        hooksConfigured = await setupClaudeHooks({ enableHooks: true, force });
      }
    }

    // Summary
    console.log();
    logger.success('Project initialized successfully!');
    console.log();
    console.log(chalk.gray('Created:'));
    console.log(chalk.gray('  .ccautorun/          - Configuration directory'));
    console.log(chalk.gray('  .ccautorun/plans/    - Execution plans'));
    console.log(chalk.gray('  .ccautorun/sessions/ - Session logs'));
    console.log(chalk.gray('  .ccautorun/logs/     - Application logs'));
    console.log(chalk.gray('  .ccautorun/archive/  - Archived plans'));

    if (hooksConfigured) {
      console.log(chalk.gray('  .claude/hooks.yaml   - Claude Code hooks configuration'));
    }

    console.log();
    console.log(chalk.cyan('Next steps:'));
    console.log(chalk.gray('  1. Generate a plan: ') + chalk.white('claude "/plan <description>"'));
    console.log(chalk.gray('  2. Run doctor check: ') + chalk.white('ccautorun doctor'));
    console.log(chalk.gray('  3. View plans: ') + chalk.white('ccautorun list'));
    console.log();

  } catch (error) {
    logger.error('Initialization failed:', error);
    throw error;
  }
}

/**
 * Setup Claude Code hooks configuration
 */
async function setupClaudeHooks(options = {}) {
  const { enableHooks = false, force = false } = options;

  try {
    // Ensure .claude directory exists
    await fs.mkdir('.claude', { recursive: true });

    // Check if hooks.yaml already exists
    const hooksPath = '.claude/hooks.yaml';
    let existingHooks = null;

    try {
      const content = await fs.readFile(hooksPath, 'utf-8');
      existingHooks = YAML.parse(content);
    } catch {
      // File doesn't exist, that's fine
    }

    // Create or update hooks.yaml
    if (existingHooks) {
      // Merge with existing configuration
      if (!existingHooks['user-prompt-submit'] || force) {
        existingHooks['user-prompt-submit'] = {
          command: 'node',
          args: ['.ccautorun/hooks/auto-continue.js'],
          enabled: enableHooks,
          background: false,
          timeout: 30000,
        };

        await fs.writeFile(hooksPath, YAML.stringify(existingHooks), 'utf-8');
        logger.success('Updated Claude Code hooks configuration');
      } else {
        logger.info('Claude Code hooks already configured');
      }
    } else {
      // Create new hooks.yaml
      await fs.writeFile(hooksPath, HOOKS_CONFIG, 'utf-8');
      logger.success('Created Claude Code hooks configuration');
    }

    // Create auto-continue hook script
    await fs.writeFile('.ccautorun/hooks/auto-continue.js', AUTO_CONTINUE_SCRIPT, 'utf-8');
    await fs.chmod('.ccautorun/hooks/auto-continue.js', 0o755);
    logger.success('Created auto-continue hook script');

    if (enableHooks) {
      logger.success(chalk.green('Auto-continue hook enabled'));
    } else {
      logger.info(chalk.yellow('Auto-continue hook created but not enabled'));
      logger.info(chalk.gray('Enable it by setting enabled: true in .claude/hooks.yaml'));
    }

    return true;
  } catch (error) {
    logger.error('Failed to setup hooks:', error.message);
    return false;
  }
}
